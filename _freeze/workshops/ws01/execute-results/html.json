{
  "hash": "a367bd28862978018a9d171e66070356",
  "result": {
    "markdown": "---\ntitle: \"Getting Started With R\"\n---\n\n\n# Installing `R` and RStudio\n\n\n::: {.cell}\n\n:::\n\n\n\nIn this course, we will be using R <https://www.r-project.org/>, an open-source \n(i.e., free) software package for data analysis. This software is available for \nessentially all computing platforms (e.g. Windows, Linux, Unix, Mac) is \nmaintained and developed by a huge community of users including many of the \nworld's foremost statisticians.\n\nR is a programming language but you may not be required to do a lot of \nprogramming for your course work. R includes functions which enables us to \nperform a full range of statistical analyses.\n\n**For installing R software, please visit\n<https://cran.stat.auckland.ac.nz/> and follow the instructions.**\n\nNote that the R software will be sitting in the background in RStudio and you \nwill not be using the standalone version of R in this course. \n\nRStudio <https://www.rstudio.com/products/rstudio/> is an integrated development \nenvironment (IDE) for R. It includes a console and a sophisticated code editor. \nIt also contains tools for plotting, history, debugging, and management of\nworkspaces and projects. RStudio has many other features such as authoring HTML, \nPDF, Word Documents, and slide shows. In order to download RStudio (Desktop \nedition, open source), go to\n\n<https://www.rstudio.com/products/rstudio/download/>\n\nDownload the installation file and run it. \n**Note that RStudio must be installed after installing R.**\n\nR/RStudio can also be run on a cloud platform at <https://rstudio.cloud/> \nafter creating a *free* account. Be aware though that some of the packages \ncovered in this course may not work in the cloud platform.\n\nIf you open RStudio, you will see something similar to the screen shot shown \nin @fig-rstud:\n\n![An RStudio window](img/Rstudio.png){#fig-rstud}\n\nRStudio has many options, such as uploading files to a server, creating documents, etc. You will be using only a few of the options. You will *not* be using the menus such as *Build*, *Debug*, *Profile* at all in this course.\n\nYou can either type or copy and paste the R codes appearing in this section on to the R Script window and run them.\n\n# Some `R` basics {.unnumbered}\n\n-   `R` is case sensitive, so `data` is not the same as `DATA`\n\n-   `<-` (read as \"gets\") is the assignment operator. That is, you use\n    `<-` to assign some content to a variable. The operator `=` has a\n    slightly different meaning but it can be used in the same way as `<-`. In R Studio, press `ALT` and minus key when you are in the R script mode\n    (File \\>\\> New File \\>\\> R Script).\n\n-   Comments are denoted by the \\# symbol. Anything after a `#` symbol\n    is ignored by `R` .\n\n-   R coding can be hard to write from scratch. \n    <span style='color: red;'>So do not hesitate to adopt R codes written by others.</span>\n    Search the internet for R code to do what you want to do. The usual `copy and paste` trick works!\n\n*Working directory*\n\nIn RStudio, set the working directory under the *Session* menu. It is a good idea to start your analysis as a new project in the File menu so that the entire work and data files can be saved and re-opened easily later on.\n\n*R/RStudio as a calculator*\n\n*In RStudio, use the File \\>\\> New File \\>\\> R Script menu to type or copy and paste the commands and execute them*\n\nType `1+1` to see `2` on the console (or `->Run` the code in RStudio).\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1+1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2\n```\n:::\n:::\n\n\nType `a=1;b=2;a/b` to see `0.5`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\na=1;b=2;a/b\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5\n```\n:::\n:::\n\n\nNote that semicolon separates various commands. It is optional to use them as long as you type the commands one by one as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\na=1\nb=2\na/b\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.5\n```\n:::\n:::\n\n\nThere are many built-in functions. Try the following.\n\n`27^3` `sqrt(10)` `round(sqrt(10),2)` `abs(-4)` `log(10)` `exp(10)`\n`rnorm(100)` `mean(rnorm(100))` `sd(rnorm(100))`\n\nYou may wonder what was the base used for `log(10)`. A help on this can be obtained by placing a question mark (`?`) before log as `?log` or by `help(log)`\n\nThere are a few exceptions. The command `?if` wont work but `?\"if\"` will. In other words, `?\"log\"` or `help(\"log\")` are safer ways of getting help on \"built-in\" functions.\n\nIn RStudio, use the R Editor (menu *File > New Script*) to type the commands and submit them (shortcut: *CNTRL+R*).`\n\n*Default examples*\n\nThe command `example()` will produce the available HELP examples, and will work for most functions. For example, try `example(boxplot)`. You will see many boxplot examples such as the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nboxplot(count ~ spray, data = InsectSprays, col = \"lightgray\")\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nThere are also demos available, explore using the command `demo()`. The basic R system produces somewhat old style graphs.\n\nSo we will be largely using the newer plotting system **ggplot** which is part of the `tidyverse` suite of packages; see <https://www.tidyverse.org/>.\n\nLet's load that package now:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n:::\n\n\nA huge number of other dedicated packages are available to improve the power of R. Many R packages are hosted at a repository called CRAN (*C*omprehensive *R* *A*rchive *N*etwork). The package install option within RStudio can download and install these optional packages under the menu `Packages >> Install`. You can also do this using the command\n`install.packages`. For example\n\n`install.packages(c(\"tidyverse\", \"car\"), dependencies = TRUE)`\n\nThis command installs two packages `tidyverse` and `car` in one go.\n\nContributed R packages are grouped in various headings at\n<https://cran.r-project.org/web/views/>. They can be installed in bulk using the `ctv` package command `install.views()`.\n\nYou might have to install quite a few packages as you work through this course.\n\n# Quarto {.unnumbered}\n\nI encourage you to get into the habit of using [Quarto](https://quarto.org/) `*.qmd` files rather than raw `*.R` files. Heard of Rmarkdown? Well, Quarto is the successor to Rmarkdown. So, if you're just starting to use R, then you should begin with Quarto rather than Rmarkdown, because most/all new development will be going into Quarto.\n\nQuarto files contain text and code, and can be 'knitted' to produce a nicely formatted document, usually in HTML or PDF format, containing sections, text, code, plots, and output. Quarto can also be used to make websites; in fact, the website for this course was made using Quarto.\n\nHere's some information to get you started: <https://quarto.org/docs/get-started/hello/rstudio.html>.\n\nAnd some other useful tips: <https://r4ds.hadley.nz/quarto>.\n\n# R Projects and GitHub {.unnumbered}\n\nInstead of putting your R code into an ordinary directory on your computer, I encourage you to use Rstudio Projects. A Project is a self-contained directory of code and data, pertaining to a particular project. You might create a single project for your work during this course, with a folder for workshops and another folder for assignments. \n\nHere's a primer on R projects: <https://r4ds.hadley.nz/workflow-scripts#projects>\n\nAn advantage of Projects is that they work nicely with [GitHub](https://github.com/), a cloud code-repository service. If you plan to do any programming during your career, you'll probably need to learn how to use GitHub. It can be a little tricky to use at first. You don't have to use it for this course, but feel free to have a go at it if you're interested.\n\nIf you're using R projects and GitHub, this online book is a great place to start: [Happy Git and GitHub for the useR](https://happygitwithr.com/).\n\n\n# Loading/Importing Data {.unnumbered}\n\nMost data sets we shall consider in this course are in a tabular form. This means that each variable is a column, each row is an observation, columns are separated by white space (or comma), and each column or row may have a name. \n\nIf the data file is stored locally, you should put the data into the same directory as your Quarto or R markdown script. That way, you can (usually) load it easily without having to type the full pathway (e.g., `mydata.csv` rather than `C:/Users/anhsmith/Work/Project1/data/mydata.csv`). Better yet, [Projects](https://r4ds.hadley.nz/workflow-scripts#projects) make this much easier.\n\nYou can also load data from the web using a URL. For example,\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nread_csv(\"https://www.massey.ac.nz/~anhsmith/data/rangitikei.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 33 Columns: 10\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (10): id, loc, time, w.e, cl, wind, temp, river, people, vehicle\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 33 × 10\n      id   loc  time   w.e    cl  wind  temp river people vehicle\n   <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>  <dbl>   <dbl>\n 1     1     1     2     1     1     2     2     1     37      15\n 2     2     1     1     1     1     2     1     2     23       6\n 3     3     1     2     1     1     2     2     3     87      31\n 4     4     2     2     1     1     2     1     1     86      27\n 5     5     2     1     1     1     2     2     2     19       2\n 6     6     2     2     1     2     1     3     3    136      23\n 7     7     1     2     2     2     2     2     3     14       8\n 8     8     1     2     1     2     2     2     3     67      26\n 9     9     1     1     2     1     3     1     2      4       3\n10    10     2     2     1     2     2     2     3    127      45\n# ℹ 23 more rows\n```\n:::\n:::\n\n\nWe'd usually want to store the data as an object though, like so:\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nrangitikei <- read_csv(\"https://www.massey.ac.nz/~anhsmith/data/rangitikei.csv\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nRows: 33 Columns: 10\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (10): id, loc, time, w.e, cl, wind, temp, river, people, vehicle\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n```\n:::\n:::\n\n\nNow the data are available in R as an object.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"show\"}\nglimpse(rangitikei)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRows: 33\nColumns: 10\n$ id      <dbl> 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,…\n$ loc     <dbl> 1, 1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1,…\n$ time    <dbl> 2, 1, 2, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 1, 2, 1, 2,…\n$ w.e     <dbl> 1, 1, 1, 1, 1, 1, 2, 1, 2, 1, 2, 1, 1, 1, 1, 2, 2, 1, 1, 1, 2,…\n$ cl      <dbl> 1, 1, 1, 1, 1, 2, 2, 2, 1, 2, 1, 2, 1, 1, 1, 2, 2, 2, 1, 2, 2,…\n$ wind    <dbl> 2, 2, 2, 2, 2, 1, 2, 2, 3, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 3, 2,…\n$ temp    <dbl> 2, 1, 2, 1, 2, 3, 2, 2, 1, 2, 2, 3, 1, 2, 2, 2, 3, 2, 2, 2, 2,…\n$ river   <dbl> 1, 2, 3, 1, 2, 3, 3, 3, 2, 3, 1, 3, 1, 3, 1, 1, 2, 1, 2, 2, 3,…\n$ people  <dbl> 37, 23, 87, 86, 19, 136, 14, 67, 4, 127, 43, 190, 50, 47, 32, …\n$ vehicle <dbl> 15, 6, 31, 27, 2, 23, 8, 26, 3, 45, 7, 53, 22, 18, 10, 3, 11, …\n```\n:::\n:::\n\n\n\nIf the data are stored as a `*.csv` or \"comma separated values\" file, then you can use the `read.csv()` or `read_csv()` function to load the file. If it's a text file with columns separated by spaces or tabs, you can use  `read.table()` or `read_table()` function. The ones with underscores ( `read_csv()` and `read_table()`) are in the `readr` package, so you'll need to load it first (though `readr` is part of `tidyverse`, so if you load `tidyverse` you're all set). \n\nYou can also load Microsoft Excel files using functions `read_excel()`, available in the `readxl` package.\n\nAs an exercise, try importing the Telomeres data file (in Excel format)\navailable at\n\n<https://rs.figshare.com/ndownloader/files/22850096>\n\nNote that Excel files usually contain blanks for missing or unreported data or allocate many rows for variable description, which can cause issues while importing them.\n\nNative R data, stored as `*.RData` or `*.rds` files, can be loaded using the `load()` or `readRDS()` functions, respectively.\n\nSQLite is a public-domain, light-weight database engine (https://sqlite.org/about.html). The R package `RSQLite` will import *.sqlite files. Databases are usually large in size, and hence R packages such as `dbplyr` can be used package to query a database.\n\n\n# Graphing with `ggplot2` {.unnumbered}\n\nThe R library `ggplot2` is very powerful for plotting but\nyou may find the syntax little strange. There are plenty of examples at the [`ggplot2` online help website](https://ggplot2.tidyverse.org/reference/). The `ggplot2` package is loaded as part of the `tidyverse` set of packages.\n\nAdvantages of `ggplot2` are the following:\n\n-   employs the \"grammar of graphics\" of [@Wilkinson]\n-   plotting involves a high level of abstraction\n-   very flexible and complete graphics system\n-   theme system for getting attractive plots\n-   Fast growing and actively developed\n\nSome disadvantages of `ggplot2` are the following:\n\n-   3-dimensional graphics (opt for `rgl` package instead)\n-   Graph-theory type graphs (nodes/edges layout; opt for `igraph` and\n    other packages)\n-   Interactive graphics (opt for `plotly`, `ggvis` and other packages)\n\n## Grammar of Graphics\n\nThe main idea behind the grammar of graphics of [@Wilkinson] is to mimic\nthe manual graphing approach and define building blocks and combine them\nto create a graphical display. The building blocks of a graph are:\n\n-   data\n-   aesthetic mapping\n-   geometric object\n-   transformation or re-expression of data\n-   scales\n-   coordinate system\n-   position adjustments\n-   faceting\n\nIf have not installed `ggplot2` or `tidyverse`, install it with the\nfollowing commands.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"ggplot2\")\n```\n:::\n\n\nWe can now load the `ggplot2` library with the commands:\n\n\n::: {.cell warninng='false'}\n\n```{.r .cell-code}\nlibrary(ggplot2)\n```\n:::\n\n\nIn order to work with `ggplot2`, we must have a `data frame` or a `tibble`\ncontaining our data. We need to specify the `aesthetics` or how the\ncolumns of our data frame can be translated into positions, colours,\nsizes, and shapes of graphical elements.\n\nThe geometric objects and aesthetics of the ggplot2 system are explained\nbelow:\n\n## Aesthetic Mapping (`aes`)\n\nIn ggplot land *aesthetic* means visualisation features or aesthetics.\nThese are\n\n-   position (i.e., on the x and y axes)\n-   color (\"outside\" color)\n-   fill (\"inside\" color)\n-   shape (of points)\n-   linetype\n-   size\n\nAesthetic mappings are set with the `aes()` function.\n\n## Geometric Objects (`geom`)\n\nGeometric objects or `geoms` are the actual marking or inking on a plot\nsuch as:\n\n-   points (`geom_point`, for scatter plots, dot plots, etc)\n-   lines (`geom_line`, for time series, trend lines, etc)\n-   boxplot (`geom_boxplot`, for boxplots)\n\n*A plot must have at least one `geom` but there is no upper limit.* In\norder to add a `geom` to a plot, the `+` operator is employed. A list of\navailable geometric objects can be obtained by typing `geom_<tab>` in\nRstudio. The following command can also be used which will open a Help\nwindow.\n\n    help.search(\"geom_\", package = \"ggplot2\")\n\nConsider the study guide dataset `rangitikei.txt` (Recreational Use of\nthe Rangitikei river). The first 10 rows of this dataset are shown\nbelow:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n   id loc time w.e cl wind temp river people vehicle\n1   1   1    2   1  1    2    2     1     37      15\n2   2   1    1   1  1    2    1     2     23       6\n3   3   1    2   1  1    2    2     3     87      31\n4   4   2    2   1  1    2    1     1     86      27\n5   5   2    1   1  1    2    2     2     19       2\n6   6   2    2   1  2    1    3     3    136      23\n7   7   1    2   2  2    2    2     3     14       8\n8   8   1    2   1  2    2    2     3     67      26\n9   9   1    1   2  1    3    1     2      4       3\n10 10   2    2   1  2    2    2     3    127      45\n```\n:::\n:::\n\n\nThe description of the variables is given below:\n\n`loc` - two locations were surveyed, coded 1, 2\\\n`time` - time of day, 1 for morning, 2 for afternoon\\\n`w.e` - coded 1 for weekend, 2 for weekday\\\n`cl`- cloud cover, 1 for \\>50%, 2 for \\<50%\\\n`wind`- coded 1 through 4 for increasing wind speed\\\n`temp` - temperature, 1, 2 or 3 increasing temp\\\n`river`- murkiness of river in 3 increasing categories\\\n`people` - number of people at that location and time\\\n`vehicle`- number of vehicles at that location at that time\\\n\nThis dataset is downloaded from the web using the following commands.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data <- read.csv(\n  \"https://www.massey.ac.nz/~anhsmith/data/rangitikei.csv\", \n  header=TRUE\n  )\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = my.data,\n       mapping = aes(x = vehicle, y = people)\n       ) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\nThe `aes` part defines the \"aesthetics\", which is how columns of the dataframe map to graphical attributes such as x and y position, colour, size, etc. An aesthetic can be either numeric or categorical and an appropriate scale will be used. After this, we add layers of graphics. `geom_point` layer is employed to map x and y and we need not specify all the options for `geom_point`.\n\nThe `aes()` can be specified within the `ggplot` function or as its own separate function. I prefer this format. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(my.data) +\n  aes(x = vehicle, y = people) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n\nWe can add a title using *labs()* or *ggtitle()* functions. Try-\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(my.data) +\n  aes(x = vehicle, y = people) +\n  geom_point() + \n  ggtitle(\"No. of people vs No. of vehicles\")\n```\n:::\n\n\nor\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(my.data)+\n  aes(x = vehicle, y = people) +\n  geom_point() + \n  labs(title = \"No. of people vs No. of vehicles\")\n```\n:::\n\n\nNote that *labs()* allows captions and subtitles.\n\n`geom_smooth` is additionally used to show trends.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(my.data) +\n  aes(x = vehicle, y = people) +\n  geom_point() + \n  geom_smooth()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using method = 'loess' and formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\nSimilar to `geom_smooth`, a variety of `geoms` are available.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(my.data) + \n  aes(x = factor(wind), y = people) +\n  geom_boxplot()\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n\nEach `geom` accepts a particular set of mappings;for example\n`geom_text()` accepts a `labels` mapping. Try-\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(my.data) +\n  aes(x = vehicle, y = people) +\n  geom_point() + \n  geom_text(aes(label = w.e), \n            size = 5)\n```\n:::\n\n\nThe faceting option allows a collection of small plots with the same\nscales. Try-\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(my.data) +\n  aes(x=vehicle, y=people) + \n  geom_point() +\n  facet_wrap(~ river) \n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-21-1.png){width=672}\n:::\n:::\n\n\nFaceting is the `ggplot2` option to create separate graphs for subsets\nof data. `ggplot2` offers two functions for creating small multiples:\n\n1. `facet_wrap()`: define subsets as the levels of a single grouping variable\n2. `facet_grid()`: define subsets as the crossing of two grouping variables\n\nThe following arguments are common to most scales in `ggplot2`:\n\n-   **name:** the first argument gives the axis or legend title\n-   **limits:** the minimum and maximum of the scale\n-   **breaks:** the points along the scale where labels should appear\n-   **labels:** the labels that appear at each break\n\nSpecific scale functions may have additional arguments. Some of the\navailable Scales are:\n\n| **Scale**         | **Examples**              |\n|-------------------|---------------------------|\n| `scale_color_`    | `scale_color_discrete`    |\n| `scale_fill_`     | `scale_fill_continuous`   |\n| `scale_size_`     | `scale_size_manual`       |\n|                   | `scale_size_discrete`     |\n|                   |                           |\n| `scale_shape_`    | `scale_shape_discrete`    |\n|                   | `scale_shape_manual`      |\n| `scale_linetype_` | `scale_linetype_discrete` |\n|                   |                           |\n| `scale_x_`        | `scale_x_continuous`      |\n|                   | `scale_x_log`             |\n|                   | `scale_x_date`            |\n| `scale_y_`        | `scale_y_reverse`         |\n|                   | `scale_y_discrete`        |\n|                   | `scale_y_datetime`        |\n\nIn RStudio, we can type `scale_` followed by TAB to get the whole list\nof available scales.\n\nTry-\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(my.data) + \n  aes(x = vehicle, y = people, color = factor(temp)) + \n  geom_point() + \n  scale_x_continuous(name = \"No. of Vehicles\") + \n  scale_y_continuous(name = \"No. of people\") + \n  scale_color_discrete(name = \"Temperature\")\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n\nThe other coding option is shown below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(my.data) +\n  aes(x = vehicle, y = people, color = factor(temp)) + \n  geom_point() + \n  xlab(\"No. of Vehicles\") + \n  ylab(\"No. of people\") + \n  labs(colour=\"Temperature\") \n```\n:::\n\n\nNote that a desired graph can be obtained in more than one way.\n\nThe `ggplot2` theme system handles plot elements (not data based) such\nas\n\n-   Axis labels\n-   Plot background\n-   Facet label background\n-   Legend appearance\n\nBuilt-in themes include:\n\n-   `theme_gray()` (default)\n-   `theme_bw()`\n-   `theme_minimal()`\n-   `theme_classic()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- ggplot(my.data) + \n  aes(x = vehicle, y = people, color = factor(temp)) + \n  geom_point()\n```\n:::\n\n\nNote that the graph is assigned an object name `p1` and nothing will be\nprinted unless we then print the object `p1`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- ggplot(my.data) + \n  aes(x = vehicle, y = people, color = factor(temp)) + \n  geom_point()\n\np1\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n\nTry-\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 + theme_light()\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np1 + theme_bw()\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\nSpecific theme elements can be overridden using `theme()`. For example:\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 + theme_minimal() +\n  theme(text = element_text(color = \"red\"))\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\nAll theme options can be seen with `?theme`.\n\nTo specify a theme for a whole document, use\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntheme_set(theme_minimal())\n```\n:::\n\n\n*Minimal graphing* can be done using the `qplot` option that will\nproduce a few standard formatted graphs quickly.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nqplot(people, vehicle, data = my.data, colour = river)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning: `qplot()` was deprecated in ggplot2 3.4.0.\n```\n:::\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\nTry-\n\n`qplot(people, data = my.data)`\n\n`qplot(people, fill=factor(river), data=my.data)`\n\n`qplot(people, data = my.data, geom = \"dotplot\")`\n\n`qplot(factor(river), people, data = my.data, geom = \"boxplot\")`\n\nA cheat sheet for `ggplot2` is available at\n<https://www.rstudio.com/resources/cheatsheets/> (optional to download).\nThere are many other packages which incorporate `ggplot2` based graphs or\ndependent on it.\n\nThe library *patchwork* allows complex composition arbitrary plots,\nwhich are not produced using the faceting option. Try\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(patchwork)\n\np1 <- qplot(people, data = my.data, geom = \"dotplot\")\np2 <- qplot(people, data = my.data, geom = \"boxplot\")\np3 <- ggplot(my.data, aes(x = vehicle, y = people)) + geom_point()\n\n(p1 + p2) / p3 + \n  plot_annotation(\"My title\", caption = \"My caption\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nBin width defaults to 1/30 of the range of the data. Pick better value with\n`binwidth`.\n```\n:::\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\n## `ggplot` builder {.unnumbered}\n\nA nice `R` package, known as `esquisse` is available to build few simple `ggplot` graphics interactively. This may help in the early stages of learning to use `ggplot` graphing.\n\nIf this package is not installed, install it first & then try.\n\n    library(esquisse)\n    options(\"esquisse.display.mode\" = \"browser\")\n    esquisse::esquisser(data = iris)\n\nYou can also load the desired dataset within `R` studio and select the dataset.\n\nThe other option is to load a dataset from the course data web folder and then launch `esquisse`. Try-\n\n    url1 <- \"https://www.massey.ac.nz/~anhsmith/data/rangitikei.RData\"\n    download.file(url = url1, destfile = \"rangitikei.RData\")\n    load(\"rangitikei.RData\")\n    esquisse::esquisser(data = rangitikei, viewer = \"browser\")\n\nYou can also download the associated R codes or save the graph within the `esquisse` web app.\n\n# `tidyverse` and related packages {.unnumbered}\n\nIn the recent years, `tidyverse` suite of packages, which includes\n`ggplot2` has become the popular tool for data handling and plotting. In this section, a brief intro to the data management packages such as `dplyr` is given.\n\nFor detailed coverage of the `tidyverse` system, go to\n<https://www.tidyverse.org/>.\n\n## `dplyr` {.unnumbered}\n\nThe following six functions of `dplyr` are very useful for data\nwrangling :\n\n-   For selecting columns, use `select()`\n-   For subsetting data, use `filter()`\n-   For re-ordering (e.g. ascending/descending), use `arrange()`\n-   For augmenting new calculated columns, use `mutate()`\n-   For computing summary measures, use `summarise()`\n-   For group-wise computations (e.g. summary measures), use\n    `group_by()`\n\nThere are many other functions such as `transmute()` which will add newly calculated columns to the existing data frame but drop all unused columns. The `across()` function  extends `group_by()` and `summarise()` functions for multiple column and function summaries.  For example, you like to report rounded data in a table, which calls for an operation across both rows and columns.\n\n## Piping\n\n::: {.callout-tip}\n\n**The piping operation is a fundamental aspect of computer programming. The semantics of pipes is taking the output from the left-hand side and passing it as input to the right-hand side.**\n\n:::\n\nThe `R` package `magrittr` introduced the pipe operator `%>%` and can be pronounced as \"then\". In RStudio windows/Linux versions, press `Ctrl+Shift+M` to insert the pipe operator. On a Mac, use `Cmd+Shift+M`. \n\n`R` also has its own pipe, `|>`, which is an alternative to `%>%`. I tend to use `|>`. If you want to change the pipe inserted automatically with `Ctrl+Shift+M`, find on the menu **Tools > Global Options**, then click on **Code** and check the box that says \"**Use Native Pipe Operator**\". \n\nWe often pipe the `dplyr` functions, and the advantage is that we show the flow of data manipulation and subsequent graphing. This approach also helps to save memory, and dataframes are not unnecessarily created, a necessity for a big data framework.\n\nTry the following examples after loading the `rangitikei` dataset.\n\n`select()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data <- read.csv(\"https://www.massey.ac.nz/~anhsmith/data/rangitikei.csv\", header=TRUE)\n\nnames(my.data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n [1] \"id\"      \"loc\"     \"time\"    \"w.e\"     \"cl\"      \"wind\"    \"temp\"   \n [8] \"river\"   \"people\"  \"vehicle\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n\nnew.data <- my.data |> \n  select(people, vehicle)\n\nnames(new.data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"people\"  \"vehicle\"\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data |> \n  select(people, vehicle) |> \n  ggplot() + \n  aes(x=people, y=vehicle) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\nWe select two columns and create a scatter plot with the above commands.\n\n`filter()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data |> \n  filter(wind==1) |> \n  select(people, vehicle) |> \n  ggplot() +\n  aes(x=people, y=vehicle) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-35-1.png){width=672}\n:::\n:::\n\n\nThe above commands filter the data for the low wind days and plots\nvehicle against people.\n\n`arrange()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data |> \n  filter(wind==1) |> \n  arrange(w.e) |> \n  select(w.e, people, vehicle)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  w.e people vehicle\n1   1    136      23\n2   1     50      22\n3   1    100      31\n4   1    470     122\n5   2     22      11\n```\n:::\n:::\n\n\n`mutate()`\n\nAssume that a \\$10 levy is collected for each vehicle. We can create\nthis new `levy` column as follows.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data |> \n  mutate(levy = vehicle*10) |> \n  select(people, levy) |> \n  ggplot() +\n  aes(x = people, y=levy) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-37-1.png){width=672}\n:::\n:::\n\n\nNote that the pipe operation was used to create a scatter plot using the\nnewly created column.\n\n`summarise()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data |> \n  summarise(total = n(), \n            avg = mean(people)\n            )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  total      avg\n1    33 71.72727\n```\n:::\n:::\n\n\nWe obtain the selected summary measures namely the total and the mean\nnumber of people. Try-\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data |> \n  filter(wind == 1) |> \n  summarise(total = n(), \n            avg = mean(people)\n            )\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  total   avg\n1     5 155.6\n```\n:::\n:::\n\n\n`group_by()`\n\nWe obtain the wind group-wise summaries below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data |> \n  group_by(wind) |> \n  summarise(total=n(), \n            avg=mean(people))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 3 × 3\n   wind total   avg\n  <int> <int> <dbl>\n1     1     5 156. \n2     2    26  59.7\n3     3     2  19  \n```\n:::\n:::\n\n\nThere are many more commands such as the `transmute` function which\nconserves the only the needed columns. Try\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data |> \n  group_by(wind, w.e) |> \n  transmute(total=n(), \n            avg=mean(people))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 33 × 4\n# Groups:   wind, w.e [6]\n    wind   w.e total   avg\n   <int> <int> <int> <dbl>\n 1     2     1    18  72.1\n 2     2     1    18  72.1\n 3     2     1    18  72.1\n 4     2     1    18  72.1\n 5     2     1    18  72.1\n 6     1     1     4 189  \n 7     2     2     8  31.8\n 8     2     1    18  72.1\n 9     3     2     1   4  \n10     2     1    18  72.1\n# ℹ 23 more rows\n```\n:::\n:::\n\n\nA simple frequency table is found using `count()`. Try-\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data |> \n  group_by(wind, w.e) |> \n  count(temp)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 10 × 4\n# Groups:   wind, w.e [6]\n    wind   w.e  temp     n\n   <int> <int> <int> <int>\n 1     1     1     1     1\n 2     1     1     3     3\n 3     1     2     3     1\n 4     2     1     1     4\n 5     2     1     2    12\n 6     2     1     3     2\n 7     2     2     2     6\n 8     2     2     3     2\n 9     3     1     2     1\n10     3     2     1     1\n```\n:::\n\n```{.r .cell-code}\nmy.data |> \n  group_by(wind, w.e) |> \n  count(temp, river)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 16 × 5\n# Groups:   wind, w.e [6]\n    wind   w.e  temp river     n\n   <int> <int> <int> <int> <int>\n 1     1     1     1     1     1\n 2     1     1     3     3     3\n 3     1     2     3     3     1\n 4     2     1     1     1     1\n 5     2     1     1     2     1\n 6     2     1     1     3     2\n 7     2     1     2     1     3\n 8     2     1     2     2     2\n 9     2     1     2     3     7\n10     2     1     3     3     2\n11     2     2     2     1     2\n12     2     2     2     3     4\n13     2     2     3     2     1\n14     2     2     3     3     1\n15     3     1     2     2     1\n16     3     2     1     2     1\n```\n:::\n:::\n\n\nThe `count()` is useful to check the balanced nature of the data when\nmany subgroups are involved.\n\n## `tidyr` {.unnumbered}\n\nBy the phrase `tidy data`, it is meant the preferred way of arranging\ndata that is easy to analyse. The principles of tidy data are:\n\n-   Each variable forms a column.\n-   Each observation forms a row.\n-   Each type of observational unit forms a table.\n\nThe hospital admissions dataset is untidy because it does allocate many\ncolumns for a variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data <- read.table(\n  \"https://www.massey.ac.nz/~anhsmith/data/hospital.txt\",\n  header=TRUE, sep=\",\")\n  \nhead(my.data)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  YEAR PERI NORTH1 NORTH2 NORTH3 SOUTH1 SOUTH2 SOUTH3\n1 1980    1      0      4     27      4     16     27\n2 1980    2      6     11     31      8     18     21\n3 1980    3      6      4     25     20     16     24\n4 1980    4      1     10     31     22     17     20\n5 1980    5      4     16     22     21     30     31\n6 1980    6      3      8     28     31     20     30\n```\n:::\n:::\n\n\nThe main response variable namely the number of admissions is allocated different columns depending on the North and South locations. This format is also called `wide format` which can be made into a tidy `long format`. Try-\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\n\nmy.data |> \n  gather(NORTH1, NORTH2, NORTH3, \n         SOUTH1, SOUTH2, SOUTH3)\n```\n:::\n\n\n   \n\nThe command `spread()` does the opposite to `gather()`. The `tidyr`\npackage many other functions such as `unite()`, `separate()` etc to deal with columns. A better approach would be to use the `dplyr` function `pivot_longer()`. Try-\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data |> \n  pivot_longer(cols = NORTH1:SOUTH3, \n               names_to = \"location\", \n               values_to = \"Admissions\")\n```\n:::\n\n\n\n\n\nThe command `pivot_wider()` does the opposite to `pivot_longer()`\n\nThe `dplyr` package also has functions to deal with two-tables which can be joined either conditionally or unconditionally using commands such as `full_join()`. For a detailed notes and examples, you may visit <https://dplyr.tidyverse.org/articles/two-table.html> but we will be using such functions very occasionally in this course.\n\nThe `reshape2` and `data.table` packages also have functions to do the same task.\n\n# A typical data analysis session in R/RStudio {.unnumbered}\n\nA data analysis session in R/RStudio involves loading the data,\ngraphing, and modelling. You finally save your outputs or produce a\nReport.\n\nWhen you begin your analysis in RStudio, start it as a new project in the File menu. You can save all your work in one go when you quit the RStudio software. You can always load your project later on to continue the analysis.\n\nFor the sack of simplicity, let us use an R default dataset called\n`stackloss` giving the operational data of a plant for the oxidation of ammonia to nitric acid.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata(\"stackloss\")\nhead(stackloss, 5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  Air.Flow Water.Temp Acid.Conc. stack.loss\n1       80         27         89         42\n2       80         27         88         37\n3       75         25         90         37\n4       62         24         87         28\n5       62         22         87         18\n```\n:::\n:::\n\n\nThe distribution of the response variable `stack.loss` is explored using\na histogram below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstackloss |> \n  ggplot() +\n  aes(stack.loss) +\n  geom_histogram(bins = 5)\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-47-1.png){width=672}\n:::\n:::\n\n\nHistograms are not good displays for small datasets. In order to see the\nsize or length of `stack.loss` data, we select the stack.loss variable\nand then summarise the size using the *n()* option.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstackloss |> \n  select(stack.loss) |> \n  summarise(n())\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n  n()\n1  21\n```\n:::\n:::\n\n\nThe following commands will also work.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlength(stackloss$stack.loss)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 21\n```\n:::\n\n```{.r .cell-code}\nstackloss |> pull(stack.loss) |> length()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 21\n```\n:::\n:::\n\n\nWe may also explore how well `stack.loss` is related `Air.Flow` to using\na scatter plot. For this, we type the command `plot`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstackloss |> \n  ggplot() +\n  aes(y=stack.loss, x=Air.Flow) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-50-1.png){width=672}\n:::\n:::\n\n\nThe relationship is roughly linear. So we may fit a straight line model\nusing the `lm` command.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst.line.model <- lm(stack.loss~Air.Flow, data=stackloss)\n```\n:::\n\n\nWe can query this model asking for its summary using the `summary()`\nfunction.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(st.line.model)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n\nCall:\nlm(formula = stack.loss ~ Air.Flow, data = stackloss)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-12.2896  -1.1272  -0.0459   1.1166   8.8728 \n\nCoefficients:\n             Estimate Std. Error t value Pr(>|t|)    \n(Intercept) -44.13202    6.10586  -7.228 7.31e-07 ***\nAir.Flow      1.02031    0.09995  10.208 3.77e-09 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 4.098 on 19 degrees of freedom\nMultiple R-squared:  0.8458,\tAdjusted R-squared:  0.8377 \nF-statistic: 104.2 on 1 and 19 DF,  p-value: 3.774e-09\n```\n:::\n:::\n\n\n`R` default model summary is bit too long.  We may just glance the overall quality measures of the fitted model as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(broom)\nlibrary(kableExtra)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'kableExtra'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:dplyr':\n\n    group_rows\n```\n:::\n\n```{.r .cell-code}\nout1 <- st.line.model |> \n  glance() |> \n  mutate(across(where(is.numeric), \n                ~round(., 2))\n         )\n\nout1 |> t() |> kable() \n```\n\n::: {.cell-output-display}\n|              |       |\n|:-------------|------:|\n|r.squared     |   0.85|\n|adj.r.squared |   0.84|\n|sigma         |   4.10|\n|statistic     | 104.20|\n|p.value       |   0.00|\n|df            |   1.00|\n|logLik        | -58.37|\n|AIC           | 122.74|\n|BIC           | 125.87|\n|deviance      | 319.12|\n|df.residual   |  19.00|\n|nobs          |  21.00|\n:::\n:::\n\n\nFor processing using Rmarkdown, we may use the codes which will give a tidy tabular output in the word-processed output.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nout1 <- st.line.model |> \n  tidy() |> \n  mutate(across(where(is.numeric), ~round(., 2)))\n\nkable(out1)\n```\n\n::: {.cell-output-display}\n|term        | estimate| std.error| statistic| p.value|\n|:-----------|--------:|---------:|---------:|-------:|\n|(Intercept) |   -44.13|      6.11|     -7.23|       0|\n|Air.Flow    |     1.02|      0.10|     10.21|       0|\n:::\n:::\n\n\nThe fitted model is shown below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(stackloss) + \n  \n  aes(\n    y = stack.loss, \n    x = Air.Flow\n    ) +\n  \n  geom_point() + \n  \n  geom_smooth(\n    method = lm, \n    se = FALSE\n    )\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n:::\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-55-1.png){width=672}\n:::\n:::\n\n\nThe fitted model can also be displayed on the scatter plot using the old style `plot` and `abline` commands.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(stack.loss ~ Air.Flow, data=stackloss)\nst.line.model <- lm(stack.loss~Air.Flow, data=stackloss)\nabline(st.line.model)\n```\n:::\n\n\n## Data Quality Checks {.unnumbered}\n\nIt is a good idea to check the quality of secondary data sourced from elsewhere. For example, there could be missing values in the dataset. Consider the Telomeres data downloaded from\n<http://www.massey.ac.nz/~anhsmith/data/rsos192136_si_001.xlsx>\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# #| eval: false\n# url <- \"http://www.massey.ac.nz/~anhsmith/data/rsos192136_si_001.xlsx\"\n# destfile <- \"rsos192136_si_001.xlsx\"\n# # \n# download.file(url, destfile)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nurl <- \"http://www.massey.ac.nz/~anhsmith/data/rsos192136_si_001.xlsx\"\ndestfile <- \"rsos192136_si_001.xlsx\"\n\ncurl::curl_download(url, destfile)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(readxl)\nrsos192136_si_001 <- read_excel(\"rsos192136_si_001.xlsx\")\n```\n:::\n\n\nThe missingness of data can be quickly explored using many R packages. The downloaded Telomeres dataset contain many missing values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(VIM)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: colorspace\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: grid\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nVIM is ready to use.\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nSuggestions and bug-reports can be submitted at: https://github.com/statistikat/VIM/issues\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'VIM'\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nThe following object is masked from 'package:datasets':\n\n    sleep\n```\n:::\n\n```{.r .cell-code}\nres <- rsos192136_si_001 |> \n  aggr(sortVar=TRUE) |> \n  summary() |> \n  pluck(\"combinations\")\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-60-1.png){width=672}\n:::\n:::\n\n\nor\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(naniar)\ngg_miss_var(rsos192136_si_001) \n```\n:::\n\n\nThe term *Missing completely at random* (MCAR) is often used to mean\nthere is there is no pattern to the missing data themselves or\nalternatively the missingness is not related to any other variable or\ndata in the dataset. In other words, the probability of missingness is\nthe same for all units. So no bias is caused by the missing data, and we\ncan discard cases with missing data when we fit models.\n\nIn practice, we often find missing data do have a relationship with\nother variables in the dataset but the actual missing values are random.\nThis situation of data conditionally missing at random is called\n*Missing at random (MAR)* data. For a particular survey question, the\nresponse rate may differ depending on the respondent's gender. In this\nsituation, the actual missingness may be random but still related to the\ngender variable.\n\n*Missing not at random (MNAR)* is the pattern when missingness is\nrelated to other variables in the dataset, as well as the values of the\nmissing data are not random. In other words, there is a predictable\npattern in the missingness. So we cannot avoid the bias when missing\ncases are omitted.\n\nThere are also situations such as censoring where we just record a\nsingle value without actually measuring the variable of interest.\n\nImputation of data can be made except for the case of MCAR type. A\nnumber of R packages are available for data imputation; see\n<https://cran.r-project.org/web/views/MissingData.html> or\n<https://stefvanbuuren.name/fimd/>. We may occasionally cover data\nimputation issue in an assignment question.\n\nThere are also R packages to perform automatic investigation for data\ncleaning. Try-\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dataMaid)\n\nmakeDataReport(rsos192136_si_001, output=\"html\", replace=TRUE)\n\n# or\nlibrary(DataExplorer)\n\ncreate_report(rsos192136_si_001)\n```\n:::\n\n\n\nRule based validation is enabled in the R package *validate*. The R\npackage *janitor* has a function get\\_dupes() to find duplicate entries\nin the dataset. *Cleaner* package will allow to clean the variables so\nthat the columns are consistent in terms of the factor, date, numerical\nvariable types. You will be largely using data that are already cleaned\nfor your assignments but be aware that you have to perform data cleaning\nand perform necessary quality checks before analysis.\n\n# Further Help {.unnumbered}\n\nThere are a number of online sources (tutorials, discussion groups etc)\nfor getting help with R. These links are available at your class Stream.\nYou may also use the advanced search facility of Goggle at\n<https://www.google.com/advanced_search>; more specifically at\n<https://stackoverflow.com>.\n\n-   For further online tutorials\n\n    -   <https://r4ds.had.co.nz/>\n    -   <https://www.datacamp.org>\n\n-   For further graphing example\n\n    -   <https://www.r-graph-gallery.com/all-graphs>\n\n-   Getting help:\n\n    -   RStudio cheat sheets:\n        <https://www.rstudio.com/resources/cheatsheets>\n    -   RStudio resources <https://resources.rstudio.com>\n    -   Recommended R packages by topic:\n        <https://cran.r-project.org/web/views/>\n    -   StackOverflow: <https://stackoverflow.com/questions/tagged/r>\n\n# R default (base) Graphing {.unnumbered}\n\nFor a simple bar chart, try\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfreq <- c(1, 2, 3, 4, 5)\nnames <- c(\"A\",\"B\",\"C\",\"D\",\"E\")\nbarplot(freq, names.arg=names)\n```\n:::\n\n\nLet us generate random data from the normal distribution *N(10,1)*\ndistribution and form a batch of data for illustrating graphing in R.\nTry the following commands one by one.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx  <-  rnorm(40, 10,1)\n\nhist(x)\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-64-1.png){width=672}\n:::\n\n```{.r .cell-code}\nboxplot(x)\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-64-2.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(x)\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-64-3.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(density(x), xlab=\"\")\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-64-4.png){width=672}\n:::\n\n```{.r .cell-code}\nstripchart(round(x,1), method = \"stack\", pch=20)\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-64-5.png){width=672}\n:::\n\n```{.r .cell-code}\nplot(ecdf(x), verticals=TRUE)\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-64-6.png){width=672}\n:::\n:::\n\n\n\n\n\nWe can form a matrix of order 3X2 or (or 2X3) and display all the above\nsix graphs in a panel. This is done using the option `par()`, which\ncontrols the graphics *par*ameters.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx  <- rnorm(40, 10,1)\n\npar(mfrow = c(2, 3))\n\nhist(x) \n\nboxplot(x)\n\nplot(x)\n\nplot(density(x), xlab='')\n\nstripchart(round(x,1), method = \"stack\", pch=20)\n\nplot(ecdf(x), verticals=TRUE)\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-65-1.png){width=576}\n:::\n:::\n\n\nAlthough we shall not cover them here, many plotting options can be set using `par()` function; including size of margins, font types, the colour of axis labels etc. See `help(\"par\")`. The option `par(new=T)` will be useful for an overlaid graph (instead of splitting a graph). Try the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx  <- rnorm(40, 10,1)\n\nplot(x, type = \"o\", pch = 1, ylab = \"\", \n     ylim = c(6.5, 13.5), lty = 1)\n\npar(new=T)\n\ny  <-  rnorm(40, 10,1)\n\nplot(y, type = \"o\", pch = 2,\n     ylab = \"Two Batches of Random Normal Data\",\n     ylim = c(6.5, 13.5), lty = 2)\n```\n:::\n\n\nNote that `pch` specifies for the plotting character and `lty` specifies\nthe line type. You can add a legend by the following command line:\n\n`legend(\"topright\", c(\"Batch I\", \"Batch II\"), pch=1:2, lty=1:2)`\n\nFor scatter and other related plots, the command is `plot()`. Try\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx  <-  rnorm(40, 10,1)\ny  <- rnorm(40, 10,1)\nplot(y~x)  # or plot(x,y) \n```\n:::\n\n\nAdd a title by the command\n\n`title(\"This is my title\")`\n\nAdd a reference line for the mean at the x-axis by the command\n\n`abline(v=10)`\n\nand again with `abline(h=10)` for the y-axis. A 45 degree (Y=X) line can be added by the command\n\n`abline(0,1) #slope, b=1, y-intercept a=1`\n\nYou may also specify two points on the graph, and ask them to be\nconnected using the command\n\n`lines(c(8, 12), c(8, 12), lty=2, col=4, lwd=2)`\n\nNote that the `line()` has extra arguments to control the line type,\nline width, and colour.\n\nThe command `rug(x)` draws will draw small vertical lines on the x-axis (the command actually suits better for one dimensional graphs such as a boxplot). Try\n\n`rug(x)`\n\n`rug(y, side=2)  #side =2 specifies y-axis`\n\nGraphs can be saved in various file formats, such as PDF (.pdf), JPEG (.jpeg or .jpg), or postscript (.ps), by enclosing the plotting function in the appropriate commands. For example, to save a simple figure as a PDF file, we use the `pdf()` function.\n\n`x  <-  1:10`\n\n`y  <-  x^2`\n\n`pdf(file = \"Fig.pdf\")`\n\n`plot(x, y)`\n\n`dev.off()`\n\nThe `command dev.off()` closes the file. You may use the copy and paste facility for processing graphs or use the RStudio option to save graphs.\n\nThe`lattice` package contains extra graphing facilities but such graphs can be produced using `ggplot2` package. Try-\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data <-read.csv(\n  \"https://www.massey.ac.nz/~anhsmith/data/tv.csv\", \n  header=TRUE)\n\nlibrary(lattice)\n\nbwplot(TELETIME ~ factor(SCHOOL), \n       data = my.data)\n```\n\n::: {.cell-output-display}\n![](ws01_files/figure-html/unnamed-chunk-68-1.png){width=672}\n:::\n:::\n\n\nIt requires a bit of coding to combine base, lattice and ggplot graphs. Try the following codes which combines three density plots of the same data produced in different styles.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(\"grid\")\nlibrary(\"ggplotify\")\n\nx= rnorm(30)\n\np1 <- as.grob(~plot(density(x)))\np1 <- as.ggplot(p1)\n\np2 <- as.grob(densityplot(x))\np2 <- as.ggplot(p2)\n\nlibrary(ggplot2)\n\np3 <- data.frame(x=x) |> \n  ggplot() + \n  aes(x) +\n  geom_density()\n\nlibrary(patchwork)\n\np1/(p2+p3)\n```\n:::\n\n\n\n\n::: {.callout-tip}\n\nIt is optional to work through the activities that follow to gain an appreciation of how R works. Do not try to remember how to do everything right now. For your assignment work, we will be given the R codes to load data, graphing and modelling. These codes will give you a head-start. Note that we often often learn R by doing and sometime making mistakes.\n\n:::\n\n\n# R Objects, Model Syntax etc. {.unnumbered}\n\nIn R, we work with objects. There are different classes of objects\nincluding: `character`, `integer`, `numeric`, `vector`, `matrix`,\n`array`, `data.frame`, `list`, `lm` (linear model). An object may belong to several classes at once.\n\nSuppose that your data consists of 4 numbers say 1 to 4. We can combine these numbers using the `c()` function namely `c(1,2,3,4)` and then assign it to `x`, an object.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1,2,3,4)\n```\n:::\n\n\nAlternatively, we can use the `scan()` function to enter the data\nmanually one by one. In practice we load/import data and these details are explained in the next section.\n\nEvidently `x` is a vector and also belongs to other classes of objects. This can be queried as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis(x)\n```\n:::\n\n\nThe main class it belongs to is queried as\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(x)\n```\n:::\n\n\nOur data are actually integers and arranged in a pattern. So we can\ndefine `x` as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:4\n```\n:::\n\n\nThe colon (`:`) operator created the desired pattern. Alternative\nexpressions include\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- seq(1, 4, by=1)\n```\n:::\n\n\nTry `is(x)` and `class(x)` and check whether our data are recognised as integer class.\n\nWe can do many mathematical manipulations on `x`. Try\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean(x)\nmin(x)\nmax(x)\nsum(x)\nsd(x)\nvar(x)\nsort(x, T)\ntrunc(x/2)\n```\n:::\n\n\nVector elements are accessed by square brackets, `[]`. Try\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx[2]+x[4]\nx[2:3]\nx[c(1,3)]\nx[-2]\n```\n:::\n\n\nAssume that our data are actually categorical codes. Then the correct way of defining the character data is to use single quotes as\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c('a', 'b', 'c', 'd')\n```\n:::\n\n\nNow try Try `is(x)` and `class(x)`. For large patterned categorical\ndata, placing quotes is laborious. So we can change the class as\nfollows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- as.character(1:4)\n```\n:::\n\n\nAssume that you have two batches of data. The first one is\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:4 \n```\n:::\n\n\nand the second one is\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- c('a', 'b', 'c', 'd')\n```\n:::\n\n\nThese two batches can be combined into a matrix as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- cbind(x,y)\n```\n:::\n\n\nHere the matrix `m` is formed by binding the columns (vectors). The\nother option is to bind as rows\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- rbind(x,y)\n```\n:::\n\n\nEvidently vectors must be of the same length for these commands to work. We can also form a matrix by splitting a vector. Try\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:6\nm <- matrix(x, byrow = TRUE, ncol = 3)\nm <- matrix(x, byrow = TRUE, ncol = 2)\n```\n:::\n\n\nand just type `m` to see the generated matrix on the R console.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm\n```\n:::\n\n\nTo access the first of row of the matrix `m`, we use `m[1,]`; to access the first column of `m`, we use `m[,1]`.\n\nA `data frame` is an R object that contains vectors; the vectors are\nstored vertically in a matrix like structure, and can be referred to by the name of the column. The main advantage of a data frame is that the variables in a data frame do not all need to be the same type; e.g. some variables can be of class numeric, and some variables can be of class character. We can create a data frame object using the `data.frame()` function. This data frame contains two small vectors, the first of which is named `ID`, and the second `NAME`. Try \n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:4\ny <- c('a', 'b', 'c', 'd')\nmy.data <-data.frame(ID=x, NAME=y)\nmy.data \n```\n:::\n\n\nWe can access the original vector of interest in the following way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data$NAME\n```\n:::\n\n\nor with `tidyverse`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data |> pull(NAME)\n```\n:::\n\n\n\nThere are times when it is useful to convert a data frame into a matrix; we can do this with the `as.matrix()` function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm <- as.matrix(my.data)\n```\n:::\n\n\nType `class(m)` and see the changes.\n\nTwo data frames can also be merged into a single data frame using the `merge` command.\n\nThe internal structure of an R object can be viewed using the diagnostic function `str()`.\n\n*Simple Manipulations*\n\nThere is always more than one-way of manipulating the data, producing summaries and tables from raw data.\n\nOne of the simplest manipulations on a batch of data we may do is to\nchange the data type say numeric to character. For example, the\ntelevision viewing time data in the text file `tv.csv` is read into a dataframe by the command line\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data <- read.csv(\n  \"https://www.massey.ac.nz/~anhsmith/data/tv.csv\", \n  header =TRUE\n  )\n```\n:::\n\n\nWe can improve the `read.csv` command to recognise the data type while reading the table as follows, using the `read_csv` command from the `readr` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data <- read_csv(\n  \"https://www.massey.ac.nz/~anhsmith/data/tv.csv\", \n  col_types = \"nfcc\"\n  )\n```\n:::\n\n\nThe argument `col_types = \"nfcc\"` stands for \\{`numeric`, `factor`, `character`, `character`\\}, to match the order of the columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 46 × 4\n   TELETIME SEX   SCHOOL STANDARD\n      <dbl> <fct> <chr>  <chr>   \n 1     1482 1     1      4       \n 2     2018 1     1      4       \n 3     1849 1     1      4       \n 4      857 1     1      4       \n 5     2027 2     1      4       \n 6     2368 2     1      4       \n 7     1783 2     1      4       \n 8     1769 2     1      4       \n 9     2534 1     1      3       \n10     2366 1     1      3       \n# ℹ 36 more rows\n```\n:::\n:::\n\n\nWe often do a summary of a numerical variable for a given categorical variable. For example, we like to see obtain the summary statistics of TV viewing times for various schools. The commands\n\n\n::: {.cell}\n\n```{.r .cell-code}\nattach(my.data)\nby(TELETIME, SCHOOL, summary)\n```\n:::\n\n\nWe employed the `by()` command above and instead, we may also use\n`tapply()` `aggregate()` functions:\n\n`tapply(TELETIME, SCHOOL, summary)`\n\n`aggregate(TELETIME, list(SCHOOL), summary)`\n\nA tabulated summary of categorical data is obtained using the `table()`\ncommand.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy.data <- read.csv(\n  \"https://www.massey.ac.nz/~anhsmith/data/rangitikei.csv\",\n  header=TRUE\n  )\n\nwind <- my.data |> pull(wind)\nriver <- my.data |> pull(river)\n\ntable(wind, river)\n```\n:::\n\n\nIt is sometimes convenient to work with matrices for some R functions\nsuch as `apply()`. For example, the number of admissions data in\n`hospital.txt` data can be formed as a matrix. Note that this is\npossible because we have the same number of observations for each\nhospital location.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata <- read.table(\n  \"https://www.massey.ac.nz/~anhsmith/data/hospital.txt\",\n  header=TRUE, \n  sep=\",\")\n\nM <- data |> \n  select(NORTH1, NORTH2, NORTH3, \n         SOUTH1, SOUTH2, SOUTH3) |> \n  sqrt()\n\nmeans <- apply(M, 1, mean)\nsds <- apply(M, 1, sd)\n\nplot(means, sds)\n```\n:::\n\n\n*R default options for Hypothesis tests and modelling*\n\nThe `stats` default package in R has a number of functions for\nperforming hypothesis tests. However you will only use the following for\nthis course:\n\n`ks.test` - Kolmogorov-Smirnov Tests\n\n`shapiro.test` - Shapiro-Wilk Normality Test\n\n`t.test` - Student's t-Test (one & two samples, paired t-test etc)\n\n`pairwise.t.test` - Pairwise t tests (for multiple comparison)\n\n`oneway.test` - Test for Equal Means in a One-Way Layout\n\n`TukeyHSD` - To Compute Tukey's Honest Significant Differences\n\n`var.test` - F Test to Compare Two Variances\n\n`bartlett.test` - Bartlett Test of Homogeneity of Variances\n\n`fisher.test` - Fisher's Exact Test for Count Data\n\n`chisq.test` - Pearson's Chi-squared Test for Count Data\n\n`cor.test` - Test for Association/Correlation Between Paired Samples\n\nThe `car` package is needed for the following:\n\n`durbinWatsonTest ` Durbin-Watson Test for autocorrelated Errors\n\n`leveneTest` Levene's Test\n\nWe will largely use the R function `lm` in this course. The syntax for specifying a model under `lm` command (and various other model related commands) is explained below:\n\nThe structure of the model is that the response variable is modelled as a function of the response variables. The symbol `~` (tilde) is used to say \"a function of\". The simple regression of `y` on `x` is therefore specified as\n\n`lm(y ~ x)`\n\nThe same applies to a one-way ANOVA in which `x` is a categorical factor. For example, consider `tv.txt` dataset and the one-way ANOVA model of `TELETIME` for `SCHOOL` is specified as follows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmydata <- read.csv(\n  \"https://www.massey.ac.nz/~anhsmith/data/tv.csv\", \n  header=TRUE\n  )\n\nmymodel <- lm(TELETIME ~ factor(SCHOOL), \n              data = mydata) # replace lm by aov and try\n\nsummary(mymodel)\n```\n:::\n\n\nThe function `summary()` gives the summary of the model (F statistics, residual SD etc). The model summary output can be stored into a text file using the function `sink()` or copy and paste in the windows version. Graphs associated with a model can be obtained using the command\n\n`plot(mymodel)`\n\nIn the above context, we may also use the specific test command which will give the same result but this test can also be performed without assuming equal variances.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noneway.test(TELETIME ~ SCHOOL, \n            var.equal = TRUE, \n            data = mydata) \n```\n:::\n\n\nFor the `lm` command, note the following:\n\n`+` indicates inclusion (not addition) of an explanatory variable in the model\n\n`-` indicates deletion (not subtraction) of an explanatory variable from the model\n\n`*` indicates the inclusion of the explanatory variables and their\ninteraction (not multiplication) between explanatory variables\n\n`:` (colon) means only interaction between explanatory variables\n\n`/` indicates the nesting (not division) of explanatory variables\n\n`|` indicates the conditioning (for example `y ~ x|z` means that y is a function of x for given z).\n\nFor our course, you will not use the last two types. Some model examples are given below:\n\n`lm(y ~ x + z)` \\#regression of y on x and z (flat surface fit)\n\n`lm(y ~ x*z)` \\#includes the interaction term ie `lm(y ~ x + z + x:z)`\n\n`lm(y ~ x + I(x^2)` \\# fits a quadratic model or use `poly(x,2)`\n\n`lm(log(y) ~ sqrt(x) + log(z))` \\#all variables are transformed\n\nAs a further example, consider a study guide dataset. The following\ncommands fit a simple regression model and then plot the fitted line on a scatter plot. Note that commands can be shortened but deliberately shown this way.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmydata <- read.csv(\n  \"https://www.massey.ac.nz/~anhsmith/data/horsehearts.csv\", \n  header=TRUE\n  )\n\nx <- mydata$EXTDIA\ny <- mydata$WEIGHT\n\nsimplereg <- lm(y ~ x)\n```\n:::\n\n\nNote that our model object `simplereg` can be queried in many ways. The command `summary()` gives the following output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(simplereg)\n# or\n# library(broom)\n# tidy(simplereg)\n# glance(simplereg)\n```\n:::\n\n\nThe command `names(simplereg)` will gives the names of many individual components of the object `simplereg` we created. For example, a plot of the residuals against the fitted values can be obtained as\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(residuals(simplereg) ~ fitted.values(simplereg))\n```\n:::\n",
    "supporting": [
      "ws01_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}